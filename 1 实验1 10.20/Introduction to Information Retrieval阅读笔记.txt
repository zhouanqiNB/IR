# 4 Index construction

==how to construct an inverted index==

this process is called **index construction** or **indexing**; the one that performs it called **indexer**

- 与索引有关的计算机硬件的知识

- blocked sort-based indexing

  高效的单机算法，设计给静态集合的，可以看做基础索引的延展性更好的版本

- single-pass in-memory indexing

  具有更好的扩展性，因为它不在内存中保存词汇

- 在非常大的数据集中 e.g. web，索引是分布式的

- 频繁变化的集合

- 更复杂的问题

## 4.1 硬件基础

## 4.2 基于块的排序索引方法

首先，我们扫描一遍文档集合得到所有的词项—文档 ID 对。然后，我们以词项为主键、文档 ID 为次键进行排序。最后，将每个词项的文档 ID 组织成倒排记录表。

> **倒排记录表**
>
> - inverted index
>
> - inverted file 倒排文件：带有倒排索引的文件
>
> - 单个词项对应的倒排记录表posting list / inverted list 
>
>   其中的每一个元素是一条倒排记录posting
>
> - 所有词项的倒排记录表加起来是全体的倒排记录表postings

本章介绍的索引构建方法均采用单遍扫描方式。

对于很多大型的语料库来说， 即使经过压缩后的倒排记录表也不可能全部加载到内存中。我们必须使用基于磁盘的外部排序算法（尽量减少磁盘随机寻道的次数，顺序读取比随机读取更快）。

BSBI就是一种这样的方法

- 第 1 步，把文档分成几个大小相等的部分；
- 第 2 步，将每个部分的词项 ID—文档 ID 对排序；
- 第 3 步，将中间产生的临时排序结果存放到磁盘中；
- 第 4 步，将所有的中间文件合并成最终的索引。

建立 倒排索引的过程包括两步：第一步是对词项 ID—文档 ID 对进行排序；第二步是将具有同一词项 ID 的所有文档 ID 放到倒排记录表中。

### merge

合并时，同时打开所有块对应的文件。内存中维护着为10个块准备的读缓冲区和最终结果的写缓冲区。

每次，选择最小的未处理词项ID处理。读入该词项的倒排记录表并且合并，合并之后写回磁盘中。

## 4.3 内存式单遍扫描索引构建方法

上面的算法需要把词项映射成id，对于大规模的文档来说，这个map太大而不好存。SPIMI是更有拓展性的算法。

# 1 布尔检索

![image-20211018194807099](C:/Users/16834/Desktop/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E5%AE%9E%E9%AA%8C/1%20%E5%AE%9E%E9%AA%8C1%2010.20/image-20211018194807099.png)